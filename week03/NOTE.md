## W2 Notes

### Scrapy 并发参数优化原理

Scrapy 的优势在于处理网络速度，之所以比较快是因为爬虫过程中大量的信息处理，底层引擎采用了 Twisted 这个异步 IO 框架，相对于 Requests 这个同步的处理方式，会有比较大的优势。

> Twisted 是异步编程模型，任务之间相互独立，用于大量 I/O框架。

这里理解起来比较难，因为是多任务，还异步。

#### 异步编程的理解过程

从最简单的同步编程过程，进阶到多任务的同步编程，先理解多任务，多进程，多线程，并发编程这些基础，再去理解会比较顺利。

- 单任务，同步
- 多任务，同步
- 多任务，异步

> 从多进程开始，多进程、多线程、协程都是希望尽可能多处理任务。

### 多进程

##### 创建新进程

产生新进程可以用以下方式：

- `os.fork()`
  - 基于C++的底层封装，其余逻辑需要自己处理，比较方便的研究进程创建的原理。
  - `res = os.fork()`返回值为0 就是子进程 `pid = os.getpid()` ，非0就是父进程 , `pid = os.getppid()`
- `multiprocessing.Process()`
  - 高级封装，方便功能实现
  - 主要参数：
    - `target`
    - `args=(),kwargs={}`
    - 进程 `join([timeout])` 如果可选参数 `timeout`是 `None` 值，则该方法将阻塞直到调用 `join()`方法的进程终止。
    - 如果 `timeout`是一个正数，它最多会阻塞 `timeout`秒。
    - 如果进程终止或者方法超时，则该方法返回 `None`。
    - 检查进程的 `exitcode`以确认它是否终止。
    - 一个车进程可以合并多次。
    - 进程无法进入自身，因为这会导致死锁。
    - 尝试在启动进程之前合并进程是错误的。

##### 多进程的第一个问题：进程的父子关系

一般把新创建的进程叫做之前进程的子进程，原有的进程为父进程。

> 父子进程是有一定的关系，单并不是说父进程退出了子进程就没有权利执行了。父进程比子进程执行更快，所以退出，但创建子进程的操作是在父进程退出之前。只要子进程被创建，他是不会管父进程的死活的，他照样执行自己的代码，直到完成自己退出。

##### 多任务处理一个重要的问题：

如果中间出现了错误，如何定位和处理？

方式1

```python
import time
from multiprocessing import Process
import os
def run():
    print("子进程开启")
    time.sleep(2)
    print("子进程结束")


if __name__ == "__main__":
    print("父进程启动")
    p = Process(target=run)
    p.start()
    # p.join()  
    print("父进程结束")
```

> 代码调试的技巧：
>
> 在函数中开始和结束的部分添加部分信息，
>
> 加入 `time.sleep()`控制时间。
>
> 在父子进程中都这么处理，查看处理过程。

如果想看到更多的信息，需要加入更多的内置函数。

- 进程的编号 `pid`
- 进程的名称 ，可以传入 `name`参数
- CPU 的信息

```python
from multiprocessing import Process
import os
import multiprocessing

def debug_info(title):
    print('-'*20)
    print(title)
    print('模块名称:', __name__)
    print('父进程:', os.getppid())
    print('当前进程:', os.getpid())
    print('-'*20)

def f(name):
    debug_info('function f')
    print('hello', name)

if __name__ == '__main__':
    debug_info('main')
    p = Process(target=f, args=('bob',))
    p.start()

    for p in multiprocessing.active_children():
        print(f'子进程名称: {p.name}  id: { str(p.pid) }' )
    print('进程结束')
    print(f'CPU核心数量: { str(multiprocessing.cpu_count()) }')
    
    p.join()
```

#### 进程之间的通信

引入多进程的第一个问题：

单进程信息传递可以用变量赋值。

多进程信息传递不能这样处理，因为变量赋值是在每个进程的堆栈当中，跨到另个进程的时候，堆栈信息是不能传递的。

引入新的进程通信机制：

- 队列 `Queue`，有高级封装的功能，使用的最多
- 管道 `Pipe` 底层工具
- 共享内存
  - `from multiprocessing import Process, Value , Array`

第二个问题：

资源的抢占，一个文本编辑器，两个人同时输入，输入的信息既不是a的,也不是 b的，有可能是乱码。会有资源竞争的问题。

用锁机制来处理，队列中就是用锁来处理的。

锁的工作原理：

两个进程操作的时候，A进程操作之前先把它锁住，其他进程先等待，A操作完之后主动把锁释放，其他进程来争抢锁，谁抢到谁执行。

需要注意的是：

> 锁只解决资源抢占问题，不解决顺序问题。

### 多线程

##### 进程与线程到底有什么区别？

进程资源独立，多进程资源开销大。多个线程跑在一个进程，同步数据方便

##### 经常提到的阻塞和非阻塞、同步和异步是什么意思 ？

阻塞和非阻塞，调用方看到的结果。发起方等就是阻塞，不等，去执行其他的了就是非阻塞。

同步异步是被调用方看到的结果。马上响应，同步。不能马上响应，但是给了回复，就是异步。

设计程序的行为的时候考虑这些因素。异步非阻塞，效率高，但是逻辑很难排错。

##### 为什么有多进程还要有多线程？反过来也是？

python 中的特殊原因，多线程只能在一个物理核心上使用，如果要多物理核心，可以用多进程。多线程做方便通信，多进程占用多的cpu。

##### 为什么要产生协程？

调度由系统控制多进程与多线程，希望进程在切换的时候更轻量级，由用户来把控的时候，就产生了协程。

多线程完成的事就是并发。

多进程完成的事就是并行。

![image-20200709204903902](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggl0evxk5cj311s0u0kbo.jpg)

##### 实际工作中如何选择？

python因为Cpython的解释器，有GIL锁，拿到锁的线程可以调用1个核心，IO操作的时候被释放，所以是伪多线程，同一时间只能有一个线程运行。所以和单独一个进程执行相等。多进程效率可能还会低，如果是IO密集型，比如爬虫，会比较有用。

